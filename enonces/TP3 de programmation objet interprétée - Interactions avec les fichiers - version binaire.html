<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>TP3 de programmation objet interprétée - Interactions avec les fichiers - version binaire</title>
    <meta name="viewport" content="width=device-width">
    <meta name="description" content="TPs mis à disposition le plus simplement possible pour mes étudiants.">
    <link rel="canonical" href="https://berlin.iut.local/~frdelobe/ruby-2a/2019/02/11/TP3_ruby/">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="TP3%20de%20programmation%20objet%20interpr%C3%A9t%C3%A9e%20-%20Interactions%20avec%20les%20fichiers%20-%20version%20binaire_fichiers/main.css">

</head>


  <body class="ruby-2a">

    <header class="site-header">

  <div class="wrap">

    <a class="site-title" href="http://berlin.iut.local/~frdelobe/">Supports de cours pour l'IUT</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 18 15" enable-background="new 0 0 18 15" xml:space="preserve">
          <path fill="#505050" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0
            h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"></path>
          <path fill="#505050" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484
            h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"></path>
          <path fill="#505050" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0
            c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"></path>
        </svg>
      </a>
      <div class="trigger">
        
          <a class="page-link" href="http://berlin.iut.local/~frdelobe/about/">About</a>
        
          
        
          
        
          <a class="page-link" href="http://berlin.iut.local/~frdelobe/categories/ruby-2a/">ruby-2a</a>
        
          <a class="page-link" href="http://berlin.iut.local/~frdelobe/categories/cpp-2a/">cpp-2a</a>
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrap">
      <div class="post">

  <header class="post-header">
    <h1>TP3 de programmation objet interprétée - Interactions avec les fichiers - version binaire</h1>
    <p class="meta">Feb 11, 2019</p>
  </header>

  <article class="post-content">
  <h2 id="objet-du-tp">Objet du TP</h2>

<ul>
  <li>Lire les argument d’un programme</li>
  <li>Lire et écrire un fichier texte.</li>
  <li>Utiliser <code class="highlighter-rouge">IO.popen</code> pour travailler en collaboration avec des outils externes</li>
  <li>Revoir un peu les expressions rationnelles</li>
  <li>Facultatif: Utiliser les fonctionnalité de <strong>pack/unpack</strong> pour lire des données binaires, en vue de reverse engineering.</li>
</ul>

<h2 id="échauffement-faire-un-logiciel-de-fortune">Échauffement: Faire un logiciel de fortune</h2>

<p>fortune est un logiciel destiné à afficher des fortunes, petits messages souvent humoristiques ou sibyllins. Le nom vient des <em>fortune cookies</em>, les gateaux chinois avec un petit message à l’intérieur.</p>

<ul>
  <li>Écrivez un script ruby <em>rfortune</em> permettant de lire un <a href="http://berlin.iut.local/~frdelobe/Data/fortunes.tgz">fichier de fortune</a> et d’en afficher une tirée au hasard. Pour ce faire, regardez le format des fichiers. Il est basé sur du texte.</li>
  <li>Ajoutez la gestion des arguments: <em>rfortune</em> accepte désormais en paramêtre le nom des fichiers de fortune qu’il peut utiliser.</li>
</ul>

<h2 id="faire-des-logs-du-temps-de-ping-moyen-dun-serveur">Faire des logs du temps de ping moyen d’un serveur</h2>

<p>Comment évolue votre connexion réseau dans le temps? On peut 
principalement étudier deux métriques: le débit, et la latence (le temps
 que met un paquet à atteindre un serveur).</p>

<p>La commande shell <code class="highlighter-rouge">ping</code> vous permet d’envoyer des paquets de contrôle <code class="highlighter-rouge">ICMP</code> et d’avoir une estimation de la latence. Celle ci, lancée sans arguments, ne s’arrête jamais. Testez un <code class="highlighter-rouge">ping londres</code></p>

<p>Néanmoins, sur un réseau non privé, la latence varie beaucoup et une 
simple valeur ne représente pas grand chose. Une moyenne donne plus 
d’informations mais finit par agréger tellement de valeurs qu’elle ne 
veut plus dire grand chose sur l’état de votre ligne à un moment donnée.</p>

<p>Nous allons donc utiliser une <em>moyenne glissante</em> (une moyenne des <em>n</em> dernières valeurs).</p>

<h3 id="étape-1">Étape 1</h3>

<p>Écrivez un programme ruby qui reçoit en argument un nom de serveur et effectue des <code class="highlighter-rouge">ping</code> sur celui ci, en affichant chacune des lignes données par le <code class="highlighter-rouge">ping</code>.</p>

<h3 id="étape-2">Étape 2</h3>

<p>À l’aide d’une expression rationnelle, extrayez de cette ligne uniquement le temps</p>

<h3 id="étape-3">Étape 3</h3>

<p>Écrivez une fonction qui calcule la moyenne d’un tableau (une ligne de ruby).</p>

<h3 id="étape-4">Étape 4</h3>

<p>Stockez le temps obtenu à l’étape 2 dans un tableau, et limitez la taille du tableau aux <em>n</em> dernières valeurs. Appelez la fonction de moyenne dessus et affichez le résultat</p>

<h3 id="étape-5">Étape 5</h3>

<p>Logguez l’intégralité dans un fichier, en ayant sur chaque ligne l’heure de la mesure et la moyenne, séparées par une espace?</p>

<h3 id="étape-6">Étape 6</h3>

<p>Vous pouvez générer des courbes de débit en utilisant les données de l’étape 5 et un programme externe (<code class="highlighter-rouge">gnuplot</code>
 par exemple). Néanmoins, de nombreuses gemmes (paquets Ruby) sont 
destinées à générer des représentations graphiques de données, que ce 
soit sous format d’image (png, pdf…) ou de programme (javascript). Nous 
vous proposons d’utiliser la gemme <code class="highlighter-rouge">gruff</code>, une gemme qui utilise les bibliothèques d’imagemagick pour générer des images.</p>

<p>Vous pouvez l’installer par <code class="highlighter-rouge">gem install --user-install gruff</code>.</p>

<p>Rappel: vous devez avoir un proxy bien configuré. Si non:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">cat</span> <span class="o">&gt;&gt;</span> <span class="o">~</span><span class="sr">/.bashrc &lt;&lt;EOF
export HTTPS_PROXY=193.49.118.36:8080
export HTTP_PROXY=193.49.118.36:8080
EOF</span></code></pre></figure>

<p>Voici un petit programme de démo pour générer un graphique simple:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="nb">require</span> <span class="s1">'gruff'</span>
<span class="n">g</span> <span class="o">=</span> <span class="no">Gruff</span><span class="o">::</span><span class="no">Line</span><span class="p">.</span><span class="nf">new</span>
<span class="n">g</span><span class="p">.</span><span class="nf">title</span> <span class="o">=</span> <span class="s2">"Graphique des trucs inutiles"</span>
<span class="n">mots</span> <span class="o">=</span> <span class="sx">%w{ compte donc les lettres des mots de cette phrase ou uniquement les voyelles}</span>
<span class="n">g</span><span class="p">.</span><span class="nf">labels</span> <span class="o">=</span> <span class="n">mots</span><span class="p">.</span><span class="nf">map</span><span class="p">.</span><span class="nf">each_with_index</span> <span class="p">{</span> <span class="o">|</span> <span class="n">w</span> <span class="p">,</span> <span class="n">i</span> <span class="o">|</span> <span class="p">[</span> <span class="n">i</span><span class="p">,</span> <span class="n">w</span><span class="p">]</span>  <span class="p">}.</span><span class="nf">to_h</span>
<span class="n">g</span><span class="p">.</span><span class="nf">marker_font_size</span> <span class="o">=</span> <span class="mi">12</span>
<span class="n">g</span><span class="p">.</span><span class="nf">data</span> <span class="s2">"Nombre de lettres par mot"</span><span class="p">,</span> <span class="n">mots</span><span class="p">.</span><span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:size</span><span class="p">)</span>
<span class="n">g</span><span class="p">.</span><span class="nf">data</span> <span class="s2">"Nombre de voyelles"</span><span class="p">,</span> <span class="n">mots</span><span class="p">.</span><span class="nf">map</span><span class="p">{</span> <span class="o">|</span><span class="n">w</span><span class="o">|</span> <span class="n">w</span><span class="p">.</span><span class="nf">gsub</span><span class="p">(</span><span class="sr">/[^aeiuoy]/</span><span class="p">,</span><span class="s1">''</span><span class="p">)}.</span><span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:size</span><span class="p">)</span>
<span class="n">g</span><span class="p">.</span><span class="nf">write</span> <span class="s1">'/tmp/o.png'</span></code></pre></figure>

<p>Générez un graphique des ping moyens.</p>

<h2 id="déchiffrons-des-fichiers-binaires-en-ruby">Déchiffrons des fichiers binaires en ruby</h2>

<p>Cet exercice est <strong>facultatif</strong>. Il ne doit bien sûr pas vous servir à faire des progrès en reverse engineering.</p>

<h3 id="la-base">La base</h3>

<p>Ce TP a pour but de vous faire travailler un problème très courant en
 informatique: la récupération de données quand on a pas le code source 
du loficiel qui les a généré. C’est utile aussi bien dans la vie 
courante (quand a on planté son téléphone et qu’on veut récupérer son 
carnet d’adresse, quand on veut exploiter les fichiers de données d’un 
jeu) ou dans la vie professionnelle (en cas de <em>pipelining</em>: interfaçage entre des logiciels qui ne parlent pas la même langue).</p>

<p>Pour ce faire, je vous propose la description du format d’un fichier 
binaire (je vous fais grâce des questions d’endianness (little/big 
endian des processeurs)):</p>

<p>Le fichier de données à traiter ( exemple <a href="http://berlin.iut.local/~frdelobe/Data/pack">pack</a> ) est d’un format connu:</p>

<ul>
  <li>Il commence par une entête de 127 octets qui ne nous intéresse pas.</li>
  <li>Il est ensuite composé d’une série d’enregistrements de taille fixe (57 octets), qui comportent les champs suivants:
    <ol>
      <li>Nom du personnage/Nom de la Tribu, codé en UTF-8 sur 50 
octets. Indice: les versions récentes de Ruby travaillent nativement en 
UTF-8.</li>
      <li>Classe du personnage, sur un octet en binaire, codée de la façon suivante:
        <ul>
          <li>0 -&gt; Troll</li>
          <li>1 -&gt; Humain</li>
          <li>2 -&gt; Elfe</li>
          <li>3 -&gt; Vulcain</li>
          <li>4 -&gt; Wookie</li>
          <li>5 -&gt; Gobelin</li>
          <li>… -&gt; Pas encore découvert. Ne pas bugguer pour autant!</li>
        </ul>
      </li>
      <li>Points de vie, sur 2 octet (peut être négatif, sisi!).</li>
      <li>Pièces d’or, sur 4 octets (on ne peut avoir de dettes).</li>
    </ol>
  </li>
  <li>On va éviter de lire tout le fichier en mémoire d’un coup (ça 
bouffe de la mémoire  sans accélérer le traitement). À l’inverse, tout 
pervers qui voudrait lire le fichier octet par octet sera condamné à 
vider le Gour de Tazenat à la petite cuillère.</li>
  <li>
    <p>Attention, certaines fonctions de lecture ont changé de nom entre
 Ruby1.9 et Ruby2.x. Adaptez vous à votre interpréteur (et préférez 
Ruby2).</p>
  </li>
  <li>Pour faire ce TP simplement, vous aurez besoin de la méthode <code class="highlighter-rouge">String#unpack</code>. Vous pourrez compléter votre lecture du manuel de référence (<code class="highlighter-rouge">ri String#unpack</code>) par cette <a href="http://vfsvp.fr/article/les-methodes-pack-et-unpack-en-ruby/">traduction d’un article</a> en Français.</li>
</ul>

<h3 id="générer-un-fichier-csv-coma-separated-values">Générer un fichier CSV (Coma Separated Values)</h3>

<ul>
  <li>Ajouter au programme précédent l’exportation vers un fichier CSV 
(simple fichier texte, un enregistrement par ligne, champs séparés par 
des virgules).</li>
</ul>

<h3 id="lectures-complémentaires-voir-annexes">Lectures complémentaires, voir annexes</h3>

<ul>
  <li>Une page sur l’exploitation des données binaires en ruby sur <a href="https://practicingruby.com/articles/binary-file-formats">Practicing Ruby</a>. Au passage, vous trouverez plein d’exemples de code sympa sur ce site, sous forme de cours/exercice/tutos.</li>
  <li>Il arrive souvent de se retrouver avec une application 
propriétaire qui produit des fichiers avec des données qui nous 
intéressent mais dont le format n’est pas traduisible vers quoi que ce 
soit d’ouvert. Pour ceux qui veulent en apprendre plus sur le 
reverse-engineering de fichier binaires, je vous conseille la lecture du
 <a href="http://wiki.xentax.com/index.php/DGTEFF">Definitive Guide to Exploring File Formats</a>.</li>
</ul>


  </article>

</div>
      </div>
    </div>

    <footer class="site-footer">

  <div class="wrap">

    <!--    <h2 class="footer-heading">Supports de cours pour l'IUT</h2> -->

    <div class="footer-col-1 column">
      <ul>
        <li>Supports de cours pour l'IUT</li>
        <li><a href="mailto:francois.delobel@uca.fr">francois.delobel@uca.fr</a></li>
      </ul>
    </div>

    <div class="footer-col-2 column">
      <ul>
        
        
      </ul>
    </div>

    <div class="footer-col-3 column">
      <p class="text">TPs mis à disposition le plus simplement possible pour mes étudiants.</p>
    </div>

  </div>

</footer>


    

</body></html>